---
marp: true
theme: espressif_devcon_2023
headingDivider: 1
---
<!-- _class: lead -->
# Async Rust for embedded systems
## Scott Mabin, Juraj Sadel, Bjoern Quentin

# Goals of this presentation

- Explore how async Rust works
- Apply it to an embedded context
- Create a working application using async Rust

# A refresher on async Rust syntax

Last years talk: [EDC22 Day 1 Talk 7: Rust on Espressif chips](https://www.youtube.com/watch?v=qeEmJ_-6fPg).

`async` in Rust adds two new keywords to the language, `async` & `await`, where 

 - `async` defines a block or function to be asynchronous
 - `await` defines yield points _within_ an `async` block or function.

# How does it work?

You can only `await` something that implements the `Future` trait.

The `Future` trait has one required method, `poll` which returns either `Poll::Ready(_)` if the asynchrous operation is complete, or `Poll::Pending` if it needs to be polled again later.

# When to poll?

You _could_ just `poll` the future in a hot loop, but this is not very efficient and will block other `async` operations from running.

```rust
while let Poll::Pending = some_fut.poll() {
    // 100% CPU used here waiting for `Poll::Ready(_)`
}
```

Ideally we'd like to do other things until the `async` operation is ready. This is where the `Waker` concept is introduced.

# The `Waker`

A `Waker` is something which can be used to signal that a future should be polled again.

`wake`ing a `Waker` can happen from anywhere, some examples being an interrupt handler, a call back function or just another function.

# Example: Async Queue

```rust
pub struct AsyncQueue {
    recv: Waker,
    // other storage implementation details
    // send waker ommited for simplicity
}
```

```rust
impl AsyncQueue {

    pub fn recv(&self) {
        // register self.recv waker ==> `Poll:Pending` ==> yield execution
    }

    pub fn send(&self) {
        // call self.recv.wake() to poll the recv future again
    }
}
```

# How to run futures - Executors

We've covered how futures work, but what do `Poll::Pending` futures actually yield to? They yield back to the executor.

The executor is the mechanism to actually run futures, it handles the response to a `wake` event and then `poll`'s that future again.

Executor is a general term, there is no trait for them, they can be implemented in various ways and each will have various features and limitations.

<!-- SPEAKERS note:
    A tip for developers: an executor is allowed to poll a future anytime, it is up to the logic in the `Future` implementation to ensure the operation is complete.
 -->

# Embedded async - embassy

A popular executor for embedded systems is the embassy project. It aims to provide, not just a executor, but a collection tools and utilities to create effective async applications.

```rust
#[embassy_executor::task]
async fn ping(mut pin: Gpio9<Input<PullDown>>) {
    loop {
        esp_println::println!("Waiting...");
        pin.wait_for_rising_edge().await.unwrap();
        esp_println::println!("Ping!");
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

<!-- SPEAKER NOTES
    Embassy only requires a time driver impl for async delays, if you have your own async delay then this is not needed
 -->

# Async tasks

Usually, the top level future is called a task. Within the task, many futures could be `await`ed. In embassy, tasks are statically allocated to avoid the need of an allocator. The `#[embassy_executor::task]` macro takes care of this for us.

Tasks are allowed to have infite loops, much like a traditional RTOS task, but **MUST** contain at least one `await` point to avoid blocking other tasks.

```rust
#[embassy_executor::task]
async fn task() {
    loop {
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

<!-- SPEAKER NOTES
    Mention that you can allocate and spawn tasks dynamically with other executors?
 -->


# Building a async wifi data logger

